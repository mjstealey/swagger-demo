[
{
	"uri": "https://mjstealey.github.io/swagger-demo/swaggeryaml/",
	"title": "swagger.yaml file",
	"tags": [],
	"description": "Environmental Exposures Swagger definition",
	"content": "Environmental Exposures API Swagger specification\n# Data Translator Environmental Exposure API # # This API provides access to environmental exposures. An exposure is # any factor outside a human body that can act upon the body to cause # a health impact, including chemical entities, biological entities, # physical factors (e.g., sunlight, temperature), and social environmental # factors (e.g., crime-induced stress, poverty). # # Exposures are parameterized by a range of temporal and spatial # factors that determine where a human has been and thus what factors they # were exposured to. # # Exposures are typically quantified at several levels: # - raw value: a measured quantity for the exposure factor typically taken # from an environmental sensor or other primary data collection method. # - exposure value: a quantity derived from raw values that computes a # a net exposure to the factor for a range of spatial and temporal # coordinates. This value is often the result of interpolating raw values # to cover all relevant spatial temporal coordinates. Values may also # combine different raw value sources, such as primary and secondary # measures of air particulates. Requests for exposure values may # require indicating the computational method and parameters. # - exposure score: a quantity derived from exposure and/or raw values that # relates the exposure value to a risk score for a particular disease. Thus # an exposure score for asthma may be different than a score for alzheimers # despite being based on the same exposure values. swagger: \u0026quot;2.0\u0026quot; info: title: \u0026quot;Environmental Exposures API\u0026quot; version: \u0026quot;1.0.0\u0026quot; contact: name: \u0026quot;Michael J. Stealey\u0026quot; email: \u0026quot;stealey@renci.org\u0026quot; url: \u0026quot;http://renci.org\u0026quot; #responsibleDeveloper: \u0026quot;Michael J. Stealey\u0026quot; #responsibleOrganization: \u0026quot;RENCI\u0026quot; description: \u0026quot;API for environmental exposure models for NIH Data Translator program\u0026quot; termsOfService: \u0026quot;None Available\u0026quot; host: exposures.renci.org basePath: /v1 schemes: - https - http paths: /exposures: get: summary: \u0026quot;Get list of exposure types\u0026quot; description: \u0026quot;Returns a list of all available exposure types\u0026quot; produces: - application/json responses: 200: description: \u0026quot;Exposure types\u0026quot; schema: type: array items: $ref: '#/definitions/exposure_type' 404: description: \u0026quot;No exposure types found\u0026quot; /exposures/{exposure_type}/values: parameters: - $ref: '#/parameters/exposure_type' get: summary: \u0026quot;Get exposure value for a given environmental factor at exposure location(s)\u0026quot; description: \u0026quot;Retrieve the computed exposure value(s) for a given environmental exposure factor, time period, and location(s).\u0026quot; produces: - application/json parameters: - $ref: '#/parameters/start_date' - $ref: '#/parameters/end_date' - $ref: '#/parameters/exposure_point' - $ref: '#/parameters/temporal_resolution' - $ref: '#/parameters/statistical_type' - $ref: '#/parameters/radius' - $ref: '#/parameters/page' responses: 200: description: OK schema: type: array items: $ref: '#/definitions/exposure' 400: description: \u0026quot;Invalid exposure parameter\u0026quot; 404: description: \u0026quot;Values not found for exposure type\u0026quot; /exposures/{exposure_type}/scores: parameters: - $ref: '#/parameters/exposure_type' get: summary: \u0026quot;Get exposure score for a given environmental factor at exposure location(s)\u0026quot; description: \u0026quot;Retrieve the computed exposure score(s) for a given environmental exposure factor, time period, and location(s).\u0026quot; produces: - application/json parameters: - $ref: '#/parameters/start_date' - $ref: '#/parameters/end_date' - $ref: '#/parameters/exposure_point' - $ref: '#/parameters/temporal_resolution' - $ref: '#/parameters/score_type' - $ref: '#/parameters/radius' - $ref: '#/parameters/page' responses: 200: description: OK schema: type: array items: $ref: '#/definitions/exposure' 400: description: \u0026quot;Invalid exposure parameters\u0026quot; 404: description: \u0026quot;Scores not found for exposure type\u0026quot; /exposures/{exposure_type}/coordinates: parameters: - $ref: '#/parameters/exposure_type' get: summary: \u0026quot;Get exposure location(s) as latitude, longitude coordinates\u0026quot; description: \u0026quot;Returns paginated list of available latitude, longitude coordinates for given exposure_type. Optionally the user can provide a latitude, longitude coordinate with a radius in meters to discover if an exposure location is within the requested range.\u0026quot; produces: - application/json parameters: - $ref: '#/parameters/latitude' - $ref: '#/parameters/longitude' - $ref: '#/parameters/radius' - $ref: '#/parameters/page' responses: 200: description: \u0026quot;Exposure points\u0026quot; schema: type: array items: $ref: '#/definitions/coordinate' 404: description: \u0026quot;No coordinates found for exposure type\u0026quot; /exposures/{exposure_type}/dates: parameters: - $ref: '#/parameters/exposure_type' get: summary: \u0026quot;Get exposure start date and end date range for exposure type\u0026quot; description: \u0026quot;Returns exposure start date and end date range for given exposure type\u0026quot; produces: - application/json responses: 200: description: \u0026quot;Date range\u0026quot; schema: $ref: '#/definitions/date_range' 404: description: \u0026quot;No date range found for exposure type\u0026quot; definitions: exposure: type: object required: - exposure_type properties: exposure_type: type: string example: \u0026quot;pm25\u0026quot; start_time: type: string format: date-time example: \u0026quot;2010-01-15T00:00:00Z\u0026quot; end_time: type: string format: date-time example: \u0026quot;2010-01-15T23:00:00Z\u0026quot; value: type: string example: \u0026quot;5.0 |OR| 17.7199974060059\u0026quot; units: type: string example: \u0026quot;7dayrisk |OR| ugm3\u0026quot; latitude: type: string format: float example: \u0026quot;35.7795897\u0026quot; longitude: type: string format: float example: \u0026quot;-78.6381787\u0026quot; exposure_type: type: object properties: exposure_type: type: string example: \u0026quot;pm25\u0026quot; description: type: string example: \u0026quot;exposure to airborne particulates: scores range from 1 (low \u0026lt; 4.0 μg/m3) to 5 (high \u0026gt; 11.37 μg/m3); values returned in μg/m3 abbreviated as ugm3\u0026quot; units: type: string example: \u0026quot;ugm3\u0026quot; has_values: type: boolean example: true has_scores: type: boolean example: true schema_version: type: string example: \u0026quot;1.0.0\u0026quot; coordinate: type: object properties: latitude: type: string format: float example: \u0026quot;35.7795897\u0026quot; longitude: type: string format: float example: \u0026quot;-78.6381787\u0026quot; date_range: type: object properties: start_date: type: string format: date-time example: \u0026quot;2010-01-01T00:00:00Z\u0026quot; end_date: type: string format: date-time example: \u0026quot;2010-01-31T00:00:00Z\u0026quot; parameters: exposure_type: name: exposure_type in: path required: true description: \u0026quot;The name of the exposure type (currently limited to pm25, o3, haz_waste, crime, res_den, poverty, ses).\u0026quot; type: string default: \u0026quot;pm25\u0026quot; start_date: name: start_date in: query required: true description: \u0026quot;The starting date to obtain exposures for (example 2010-01-06 is January 6th 2010).\u0026quot; type: string format: date default: \u0026quot;2010-01-06\u0026quot; end_date: name: end_date in: query required: true description: \u0026quot;The ending date to obtain exposures for (example 2010-01-15 is January 15th 2010).\u0026quot; type: string format: date default: \u0026quot;2010-01-15\u0026quot; temporal_resolution: name: temporal_resolution in: query required: false description: \u0026quot;The temporal resolution to use for results, should be one of 'hour' or 'day'. Default is 'day'\u0026quot; type: string default: 'day' score_type: name: score_type in: query required: false description: \u0026quot;The exposure score type to return. The accepted values vary by exposure type. For pm25 values are '7dayrisk', '14dayrisk'. Default is '7dayrisk' (NOT COMPLETE).\u0026quot; type: string default: '7dayrisk' statistical_type: name: statistical_type in: query required: false description: \u0026quot;The statistic to use for results, should be one of 'max', 'mean', or 'median'. Default is 'max'\u0026quot; type: string default: 'max' exposure_point: name: exposure_point in: query required: true description: \u0026quot;A description of the location(s) to retrieve the exposure for. Locaton may be a single geocoordinate (example '35.9131996,-79.0558445') or a semicomma separated list of geocoord:dayhours giving the start and ending hours on specific days of the week at that location (example '35.9131996,-79.0558445,Sa0813;35.7795897,-78.6381787,other') indicates Saturdays from 8am to 1pm is at one location and all other times are at another location. Hours should be in 24 hours time using 2 digits, days of the week should be the first two characters of the day.If the day of the week does not appear then the time periods apply to all days (example '35.9131996,-79.0558445,0614,35.7795897,-78.6381787,1424') gives two time periods for all days. If hours do not appear then the time period applies to all hours of the day (example '35.9131996,-79.0558445,Sa,35.7795897,-78.6381787,Su').\u0026quot; type: string default: \u0026quot;35.9131996,-79.0558445\u0026quot; latitude: name: latitude in: query required: false description: \u0026quot;Search coordinates that match or are like 'latitude'\u0026quot; type: string default: \u0026quot;\u0026quot; longitude: name: longitude in: query required: false description: \u0026quot;Search coordinates that match or are like 'longitude'\u0026quot; type: string default: \u0026quot;\u0026quot; radius: name: radius in: query required: false description: radius in meters to search within for exposure point coordinate is provided. Range from 0 to 500 type: string default: \u0026quot;0\u0026quot; page: name: page in: query required: false description: \u0026quot;Page number. Return up to 100 items per page\u0026quot; type: string default: 1  "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/exposures/",
	"title": "6. Exposures API",
	"tags": [],
	"description": "Exposures API Example",
	"content": " Example of how the Exposures API took shape using Swagger.\nSpecification in Swagger At the start we had a notion of the data we wanted to serve, a list of sources to get it from, and a good idea of what this data looked like with some example datasets in a PostgreSQL / PostGIS database. Based on this information a specification file was started prior to the existence of any ReSTful service provider, so going down the rabbit hole of the swagger eco-system seemed a sensible thing to do.\nWe started with a specification in swagger:\nswagger: \u0026quot;2.0\u0026quot; info: title: \u0026quot;Environmental Exposures API\u0026quot; version: \u0026quot;1.0.0\u0026quot; contact: name: \u0026quot;Michael J. Stealey\u0026quot; email: \u0026quot;stealey@renci.org\u0026quot; url: \u0026quot;http://renci.org\u0026quot; #responsibleDeveloper: \u0026quot;Michael J. Stealey\u0026quot; #responsibleOrganization: \u0026quot;RENCI\u0026quot; description: \u0026quot;API for environmental exposure models for NIH Data Translator program\u0026quot; termsOfService: \u0026quot;None Available\u0026quot; host: exposures.renci.org basePath: /v1 schemes: - https - http paths: /exposures: get: summary: \u0026quot;Get list of exposure types\u0026quot; description: \u0026quot;Returns a list of all available exposure types\u0026quot; produces: - application/json responses: 200: description: \u0026quot;Exposure types\u0026quot; schema: type: array items: $ref: '#/definitions/exposure_type' 404: description: \u0026quot;No exposure types found\u0026quot; ...  A couple early versions of the specification did make it into the smartAPI registry, but when copying an updated specification to the smart-api.info/editor it yielded no errors, however when the “Save” button is pressed it generates a pop-up error, even though the editor states “All changes saved”.\nReference: Error\u0026quot;\u0026lt;html\u0026gt;\u0026lt;title\u0026gt;500: Internal Server Error\u0026lt;/title\u0026gt;\u0026lt;body\u0026gt;500: Internal Server Error\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot;\nPython-Flask Server Python Client "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": " Swagger: http://swagger.io Swaggerhub: https://app.swaggerhub.com/ Github swagger-api: https://github.com/swagger-api SmartAPI: http://smart-api.info/ Exposures-api: https://github.com/mjstealey/exposures-api Docker: https://www.docker.com Open API: https://github.com/OAI/OpenAPI-Specification  "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/apiclient/",
	"title": "5. API Client",
	"tags": [],
	"description": "",
	"content": "The swagger codegen project allows generation of API client libraries (SDK generation), server stubs and documentation automatically given an OpenAPI Spec.\nAPI clients:\n ActionScript, Apex, Bash, C# (.net 2.0, 4.0 or later), C++ (cpprest, Qt5, Tizen), Clojure, Dart, Elixir, Go, Groovy, Haskell, Java (Jersey1.x, Jersey2.x, OkHttp, Retrofit1.x, Retrofit2.x, Feign), Kotlin, Node.js (ES5, ES6, AngularJS with Google Closure Compiler annotations) Objective-C, Perl, PHP, Python, Ruby, Scala, Swift (2.x, 3.x), Typescript (Angular1.x, Angular2.x, Fetch, jQuery, Node)  If the server code has adhered to the contract as defined in the specification file, then the client code should \u0026ldquo;just work\u0026rdquo;.\nClient code will interpret responses from the server in accordance to the language specified. As an example, python clients will encode things in single quotes, whereas standard JSON is double quoted.\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/apiserver/",
	"title": "4. API Server",
	"tags": [],
	"description": "",
	"content": "Server generation is still strictly a developer task and swagger isn\u0026rsquo;t providing any particular magic here.\nIf you already have a server that delivers valid output in accordance with your swagger specification, then you\u0026rsquo;re done with this section and can move on.\nIf you\u0026rsquo;re starting from scratch and the swagger specification is the first step for your project, then swagger codegen may be of interest to you.\nSwagger Codegen: Remove tedious plumbing and configuration by generating boilerplate server code in over 20 different languages\nServer stubs:\n C# (ASP.NET Core, NancyFx), Erlang, Go, Haskell, Java (MSF4J, Spring, Undertow, JAX-RS: CDI, CXF, Inflector, RestEasy), PHP (Lumen, Slim, Silex, Zend Expressive), Python (Flask), NodeJS, Ruby (Sinatra, Rails5), Scala (Finch, Scalatra)  Server stub generator HOWTO\nThe server stubs will use the naming conventions as encoded in the specification file and generate the templates required to start encoding the logic for your server.\nIt should be noted that there is no safeguards against doing nonsensical things and making a mess of your server code.\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/apispec/",
	"title": "3. API Specification",
	"tags": [],
	"description": "",
	"content": " The OpenAPI Specification (fka The Swagger Specification) The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service.\nUse cases for machine-readable API interfaces include interactive documentation, code generation for documentation, client, and server, as well as automated test cases. OpenAPI-enabled APIs expose JSON files that correctly adhere to the OpenAPI Specification, documented in this repository. These files can either be produced and served statically, or be generated dynamically from your application.\nWithout going into a long history of interfaces to Web Services, this is not the first attempt to do so. We can learn from CORBA, WSDL and WADL. These specifications had good intentions but were limited by proprietary vendor-specific implementations, being bound to a specific programming language, and goals which were too open-ended. In the end, they failed to gain traction.\nOpenAPI does not require you to rewrite your existing API. It does not require binding any software to a service\u0026ndash;the service being described may not even be yours. It does, however, require the capabilities of the service be described in the structure of the OpenAPI Specification. Not all services can be described by OpenAPI\u0026ndash;this specification is not intended to cover every possible use-case of a REST-ful API. OpenAPI does not define a specific development process such as design-first or code-first. It does facilitate either technique by establishing clear interactions with a REST API.\nThis GitHub project is the starting point for OpenAPI. Here you will find the information you need about the OpenAPI Specification, a simple static sample of what it looks like, and some general information regarding the project.\nThe pre-release OAS 3.0.0 Specification Branch\nsmartAPI Specification This document presents a set of 54 metadata elements (organized into five categories) to usefully describe Web-based Application Programming Interfaces (APIs). These elements were developed by the Big Data to Knowledge (BD2K) API Interoperability Working Group, which conducted a survey of API metadata used in the real world. This group developed the smartAPI Specification as an extension of existing repositories such as Programmable Web, Biocatalogue, and available standards including Open API, schema.org, etc. The aim of the BD2K API Interoperability Working Group is to develop a strategy for maximizing interoperability and reuse of Web-based APIs. This specification aims to serve as a standard for API development that will facilitate the efficient communication among APIs and reduce development costs. The smartAPI Specification includes 21 metadata elements beyond those included in the Open API Initiative. The metadata elements are grouped into categories related to APIs, service providers, API operations, operation parameters, and operation responses. For each category, the metadata elements that are mandatory, recommended, or optional are described and illustrated by examples. The widespread adoption of the smartAPI Specification by the community promises to improve the efficiency and lower the costs of API development, promoting cross-API compatibility and resolving current challenges in API usage.\nSpecification enforcement Specification is enforced within the editor as seen in this example.\n Left: responsibleOrganization is left uncommented and violates OpenAPI specification for valid additionalProperty Right: responsibleDeveloper is commented and violates smartAPI specification for \u0026ldquo;Missing required property: responsibleDeveloper\u0026rdquo;  "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/smartapi/",
	"title": "2. Swagger vs SmartAPI",
	"tags": [],
	"description": "",
	"content": " What is a smartAPI? The smartAPI project aims to maximize the FAIRness (Findability, Accessibility, Interoperability, and Reusability) of web-based Application Programming Interfaces (APIs). Rich metadata is essential to properly describe your API so that it becomes discoverable, connected, and reusable. We have developed a openAPI-based specification for defining the key API metadata elements and value sets. smartAPIs leverage the Hydra Web API specification and JSON-LD for providing semantically annotated JSON content that can be treated as Linked Data.\nsmartAPI Editor: A tool for semantic annotation of Web APIs smartAPI Editor is an an extension to Swagger Editor. Swagger Editor lets you edit your API document in in YAML inside your browser and to preview documentations in real time.\nsmartAPI editor:\n Validates your API document against smartAPI specifications, an extended version of openAPI specification. Lets you Save your API document into smartAPI registry. Enhances auto-suggestion functionality for metadata elements by providing the element\u0026rsquo;s conformance level (Required, Recommended, Optional). Enhances auto-suggestion functionality for metadata values by suggesting a list of values used by other APIs along with and sorted by their usage frequency. Enables semantic annotation of parameters and responses of the API:  auto-suggests values for parameters.parameterValueType from identifiers.org along with their usage frequency by other APIs. Integrates the editor with smartAPI profiler which automatically annotates the responses.responseDataType of the API.   Why do we need smartAPIs? Data analysis is increasingly being performed using cloud-based, web-friendly application programming interfaces (APIs). Thousands of tools and APIs are available through web service registries such as Programmable Web, BioCatalogue and cloud platforms such as Galaxy. Searching these and other API repositories to find a set of tools to retrieve or operate on data of interest presents a number of formidable challenges: users must not only supply the right combination of search terms, but must also closely examine the API outputs to determine whether they can be connected together. SmartAPIs tackle this challenge because they contain the rich metadata needed to precisely describe the service and the data that it operates on or provides.\nWhat does the smartAPI offer? Richly annotated APIs will provide the assets by which users will be able to search, browse, query, and reuse APIs. Users and intelligent agents being able to traverse a highly connected network of smartAPIs. Users will be able to automatically find APIs whose outputs are the inputs for other services. Ultimately, we envision the automatic generation of workflows that take users to where they want to go with what they have today.\nQuestions / Concerns regarding smartAPI NOTE: The following observations should be taken with a grain of salt as the smartAPI effort is still under development.\nLooks to have recently diverged it\u0026rsquo;s source from the swagger fork it was using: https://github.com/WebsmartAPI/smartAPI-editor\n Don\u0026rsquo;t know if this was strictly for DOI purposes, or for ongoing work, but detaching from the original repository makes it difficult to include future improvements made to swagger itself. The branch from which the DOI version is from shows This branch is 54 commits ahead, 190 commits behind swagger-api:master. So there is concern about the fork growing stale with respect to the current state of OpenAPI as implemented in swagger. The OpenAPI Specification (OAS) 3.0 is in pre-release and it\u0026rsquo;s unclear how this would be ported into smartAPI.  It was denoted during that hackathon that parameters were not necessarily parsed as expected when compared to standard swagger.\n This was denoted with the Broad probabilistic graphical models translator and brought to Michel\u0026rsquo;s attention. Transferred swagger.yaml file to swagger-editor for testing and syntax passed once smartAPI specific components were commented out.  Seemingly valid syntax from swagger-editor is not always accepted by smartAPI-editor\n The editor wouldn\u0026rsquo;t flag anything in particular, but the spec would fail when attempting to save to the registry with a 500 error.  "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/swagger/",
	"title": "1. What is Swagger?",
	"tags": [],
	"description": "",
	"content": " Swagger allows you to describe the structure of your APIs so that machines can read them.\nThe ability of APIs to describe their own structure is the root of all awesomeness in Swagger. Why is it so great? Well, by reading your API’s structure, we can automatically build beautiful and interactive API documentation. We can also automatically generate client libraries for your API in many languages and explore other possibilities like automated testing.\nSwagger does this by asking your API to return a YAML or JSON that contains a detailed description of your entire API. This file is essentially a resource listing of your API which adheres to OpenAPI Specification. The specification asks you to include information like:\n What are all the operations that your API supports? What are your API’s parameters and what does it return? Does your API need some authorization? And even fun things like terms, contact information and license to use the API.  You can write a Swagger spec for your API manually, or have it generated automatically from annotations in your source code. Check swagger.io/open-source-integrations for a list of tools that let you generate Swagger from code.\nThe goal of Swagger is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined via Swagger, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming, Swagger removes the guesswork in calling the service.\nTechnically speaking - Swagger is a formal specification surrounded by a large ecosystem of tools, which includes everything from front-end user interfaces, low-level code libraries and commercial API management solutions.\nSwagger Editor Why are there two different UIs for Swagger? Indeed there are two different user interfaces for working with Swagger definitions. The Editor tab provides a YAML-based text editor with contextual auto-suggestions for content. On the right side of the screen, a live rendering is produced, making it easy to visualize the API definition that you’re creating.\nAlternatively the UI tab will show you a read only view of the API, tailored for consumers of the API. We have found that these distinct views give the most flexibility for understanding the intent of the API.\nLearn more here.\nWhat is SwaggerHub for? SwaggerHub is an integrated API Development platform, built for teams, that brings the core capabilities of the Swagger framework to design, build, document and deploy APIs. SwaggerHub enables development teams to collaborate and coordinate the entire lifecycle of an API with the flexibility to integrate with the toolset of your choice.\nBut I use GitHub / BitBucket / GitLab, how is this different? Source control is great for source. But API definitions aren’t quite the same - they deserve their own, first-class treatment. SwaggerHub works in conjunction with version control systems, so hunting through source code should no longer be necessary.\nSwaggerHub integrations does allow connections to the GitHub, GitLab and Bitbucket, with others on the way.\nWhat are Integrations? Integrations are free add-ons to your API definition on SwaggerHub to improve and expand its functionality. These Integrations help connect your API to a host of 3rd party tools which allow you to go beyond just API design on SwaggerHub! You could sync your definition with a GitHub repository, quickly generate a mock for your Swagger definition or create a webhook to trigger for certain events on SwaggerHub!\nWhat does Publishing an API do? When you create an API and make it available for users to consume, you are creating a contract for them. They rely on that definition to work a certain way, and breaking changes will potentially break their integrations.\nPublishing an API is specific to a single version of an API. You should do so when the API ships and users can rely on the signatures. It tells your teams and consumers that your API is in a stable state. Once published, it is read-only and cannot be changed.\nWhen published, you should consider making changes in a new version of your API.\nAfter you publish, you may want to update the default version of the API. This is what is shown in search results, or when someone navigates to your API directly without a specific version number. You can learn more about versioning here.\nOf course, there are always unforeseen situations where you may have a typo or need to make an emergency change. You can Unpublish your API but please do so carefully. Trust with your users is precious!\nLearn more about publishing APIs here.\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/",
	"title": "Home",
	"tags": [],
	"description": "homepage",
	"content": " Swagger Demo A brief demo / tutorial reviewing the basics of Swagger and how it relates to smartAPI. The Exposures API work will be used to illustrate some topics in this demo.\n1. What is Swagger? 2. Swagger vs SmartAPI 3. API Specification 4. API Server 5. API Client 6. Exposures API References "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/_header/",
	"title": "header",
	"tags": [],
	"description": "header",
	"content": "Swagger Demo\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]