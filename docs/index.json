[
{
	"uri": "https://mjstealey.github.io/swagger-demo/exposures/",
	"title": "6. Exposures API",
	"tags": [],
	"description": "Exposures API Example",
	"content": "Example of how Exposures API took shape using Swagger.\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": " Swagger: http://swagger.io Swaggerhub: https://app.swaggerhub.com/ Github swagger-api: https://github.com/swagger-api SmartAPI: http://smart-api.info/ Exposures-api: https://github.com/mjstealey/exposures-api Docker: https://www.docker.com Open API: https://github.com/OAI/OpenAPI-Specification  "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/apiclient/",
	"title": "5. API Client",
	"tags": [],
	"description": "",
	"content": "The swagger codegen project allows generation of API client libraries (SDK generation), server stubs and documentation automatically given an OpenAPI Spec.\nAPI clients:\n ActionScript, Apex, Bash, C# (.net 2.0, 4.0 or later), C++ (cpprest, Qt5, Tizen), Clojure, Dart, Elixir, Go, Groovy, Haskell, Java (Jersey1.x, Jersey2.x, OkHttp, Retrofit1.x, Retrofit2.x, Feign), Kotlin, Node.js (ES5, ES6, AngularJS with Google Closure Compiler annotations) Objective-C, Perl, PHP, Python, Ruby, Scala, Swift (2.x, 3.x), Typescript (Angular1.x, Angular2.x, Fetch, jQuery, Node)  "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/apiserver/",
	"title": "4. API Server",
	"tags": [],
	"description": "",
	"content": "Swagger Codegen: Remove tedious plumbing and configuration by generating boilerplate server code in over 20 different languages\nServer stubs:\n C# (ASP.NET Core, NancyFx), Erlang, Go, Haskell, Java (MSF4J, Spring, Undertow, JAX-RS: CDI, CXF, Inflector, RestEasy), PHP (Lumen, Slim, Silex, Zend Expressive), Python (Flask), NodeJS, Ruby (Sinatra, Rails5), Scala (Finch, Scalatra)  Server stub generator HOWTO\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/apispec/",
	"title": "3. API Specification",
	"tags": [],
	"description": "",
	"content": " The OpenAPI Specification (fka The Swagger Specification) The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service.\nUse cases for machine-readable API interfaces include interactive documentation, code generation for documentation, client, and server, as well as automated test cases. OpenAPI-enabled APIs expose JSON files that correctly adhere to the OpenAPI Specification, documented in this repository. These files can either be produced and served statically, or be generated dynamically from your application.\nWithout going into a long history of interfaces to Web Services, this is not the first attempt to do so. We can learn from CORBA, WSDL and WADL. These specifications had good intentions but were limited by proprietary vendor-specific implementations, being bound to a specific programming language, and goals which were too open-ended. In the end, they failed to gain traction.\nOpenAPI does not require you to rewrite your existing API. It does not require binding any software to a service\u0026ndash;the service being described may not even be yours. It does, however, require the capabilities of the service be described in the structure of the OpenAPI Specification. Not all services can be described by OpenAPI\u0026ndash;this specification is not intended to cover every possible use-case of a REST-ful API. OpenAPI does not define a specific development process such as design-first or code-first. It does facilitate either technique by establishing clear interactions with a REST API.\nThis GitHub project is the starting point for OpenAPI. Here you will find the information you need about the OpenAPI Specification, a simple static sample of what it looks like, and some general information regarding the project.\nThe pre-release OAS 3.0.0 Specification Branch\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/smartapi/",
	"title": "2. Swagger vs SmartAPI",
	"tags": [],
	"description": "",
	"content": " What is a smartAPI? The smartAPI project aims to maximize the FAIRness (Findability, Accessibility, Interoperability, and Reusability) of web-based Application Programming Interfaces (APIs). Rich metadata is essential to properly describe your API so that it becomes discoverable, connected, and reusable. We have developed a openAPI-based specification for defining the key API metadata elements and value sets. smartAPIs leverage the Hydra Web API specification and JSON-LD for providing semantically annotated JSON content that can be treated as Linked Data.\nsmartAPI Editor: A tool for semantic annotation of Web APIs smartAPI Editor is an an extension to Swagger Editor. Swagger Editor lets you edit your API document in in YAML inside your browser and to preview documentations in real time.\nsmartAPI editor:\n Validates your API document against smartAPI specifications, an extended version of openAPI specification. Lets you Save your API document into smartAPI registry. Enhances auto-suggestion functionality for metadata elements by providing the element\u0026rsquo;s conformance level (Required, Recommended, Optional). Enhances auto-suggestion functionality for metadata values by suggesting a list of values used by other APIs along with and sorted by their usage frequency. Enables semantic annotation of parameters and responses of the API:  auto-suggests values for parameters.parameterValueType from identifiers.org along with their usage frequency by other APIs. Integrates the editor with smartAPI profiler which automatically annotates the responses.responseDataType of the API.   Why do we need smartAPIs? Data analysis is increasingly being performed using cloud-based, web-friendly application programming interfaces (APIs). Thousands of tools and APIs are available through web service registries such as Programmable Web, BioCatalogue and cloud platforms such as Galaxy. Searching these and other API repositories to find a set of tools to retrieve or operate on data of interest presents a number of formidable challenges: users must not only supply the right combination of search terms, but must also closely examine the API outputs to determine whether they can be connected together. SmartAPIs tackle this challenge because they contain the rich metadata needed to precisely describe the service and the data that it operates on or provides.\nWhat does the smartAPI offer? Richly annotated APIs will provide the assets by which users will be able to search, browse, query, and reuse APIs. Users and intelligent agents being able to traverse a highly connected network of smartAPIs. Users will be able to automatically find APIs whose outputs are the inputs for other services. Ultimately, we envision the automatic generation of workflows that take users to where they want to go with what they have today.\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/swagger/",
	"title": "1. What is Swagger?",
	"tags": [],
	"description": "",
	"content": " Swagger allows you to describe the structure of your APIs so that machines can read them.\nThe ability of APIs to describe their own structure is the root of all awesomeness in Swagger. Why is it so great? Well, by reading your API’s structure, we can automatically build beautiful and interactive API documentation. We can also automatically generate client libraries for your API in many languages and explore other possibilities like automated testing.\nSwagger does this by asking your API to return a YAML or JSON that contains a detailed description of your entire API. This file is essentially a resource listing of your API which adheres to OpenAPI Specification. The specification asks you to include information like:\n What are all the operations that your API supports? What are your API’s parameters and what does it return? Does your API need some authorization? And even fun things like terms, contact information and license to use the API.  You can write a Swagger spec for your API manually, or have it generated automatically from annotations in your source code. Check swagger.io/open-source-integrations for a list of tools that let you generate Swagger from code.\nThe goal of Swagger is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined via Swagger, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming, Swagger removes the guesswork in calling the service.\nTechnically speaking - Swagger is a formal specification surrounded by a large ecosystem of tools, which includes everything from front-end user interfaces, low-level code libraries and commercial API management solutions.\nSwagger Editor Why are there two different UIs for Swagger? Indeed there are two different user interfaces for working with Swagger definitions. The Editor tab provides a YAML-based text editor with contextual auto-suggestions for content. On the right side of the screen, a live rendering is produced, making it easy to visualize the API definition that you’re creating.\nAlternatively the UI tab will show you a read only view of the API, tailored for consumers of the API. We have found that these distinct views give the most flexibility for understanding the intent of the API.\nWhat are Integrations? Integrations are free add-ons to your API definition on SwaggerHub to improve and expand its functionality. These Integrations help connect your API to a host of 3rd party tools which allow you to go beyond just API design on SwaggerHub! You could sync your definition with a GitHub repository, quickly generate a mock for your Swagger definition or create a webhook to trigger for certain events on SwaggerHub!\nLearn more here.\nWhat is SwaggerHub for? SwaggerHub is an integrated API Development platform, built for teams, that brings the core capabilities of the Swagger framework to design, build, document and deploy APIs. SwaggerHub enables development teams to collaborate and coordinate the entire lifecycle of an API with the flexibility to integrate with the toolset of your choice.\nBut I use GitHub / BitBucket / GitLab, how is this different? Source control is great for source. But API definitions aren’t quite the same - they deserve their own, first-class treatment. SwaggerHub works in conjunction with version control systems, so hunting through source code should no longer be necessary.\nSwaggerHub does allow connections to the GitHub, GitLab and Bitbucket, with others on the way. See here to learn more about our integrations.\nWhat does Publishing an API do? When you create an API and make it available for users to consume, you are creating a contract for them. They rely on that definition to work a certain way, and breaking changes will potentially break their integrations.\nPublishing an API is specific to a single version of an API. You should do so when the API ships and users can rely on the signatures. It tells your teams and consumers that your API is in a stable state. Once published, it is read-only and cannot be changed.\nWhen published, you should consider making changes in a new version of your API.\nAfter you publish, you may want to update the default version of the API. This is what is shown in search results, or when someone navigates to your API directly without a specific version number. You can learn more about versioning here.\nOf course, there are always unforeseen situations where you may have a typo or need to make an emergency change. You can Unpublish your API but please do so carefully. Trust with your users is precious!\nLearn more about publishing APIs here.\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/",
	"title": "Home",
	"tags": [],
	"description": "homepage",
	"content": " Swagger Demo A brief demo / tutorial reviewing the basics of Swagger and how it relates to smartAPI. The Exposures API work will be used to illustrate some topics in this demo.\n1. What is Swagger? 2. Swagger vs SmartAPI 3. API Specification 4. API Server 5. API Client 6. Exposures API References "
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/_header/",
	"title": "header",
	"tags": [],
	"description": "header",
	"content": "Swagger Demo\n"
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://mjstealey.github.io/swagger-demo/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]